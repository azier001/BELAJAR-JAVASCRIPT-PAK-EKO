# 🔐 Symbol

## 📋 Penjelasan

- Symbol merupakan tipe data yang digaransi akan selalu **unique** setiap kali kita membuat data symbol
- Symbol kadang banyak digunakan untuk membuat key pada object
- 📚 [Dokumentasi MDN](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol)

---

## 💻 Contoh Kode

### 1️⃣ Membuat Symbol Dasar

```javascript
// Membuat symbol tanpa deskripsi
const symbol1 = Symbol();
const symbol2 = Symbol();

console.log(symbol1 === symbol2); // false - setiap symbol selalu unique!
console.log(typeof symbol1); // "symbol"
```

**Output:**
```
false
symbol
```

**Penjelasan Detail:**
- `Symbol()` menciptakan nilai primitif yang **benar-benar unik** setiap kali dipanggil
- Pada contoh di atas, `symbol1` dan `symbol2` adalah dua entitas yang **berbeda**, meskipun dibuat dengan cara yang identik
- Perbandingan `symbol1 === symbol2` menghasilkan `false` karena **setiap Symbol memiliki identitas unik**
- `typeof symbol1` mengembalikan `"symbol"`, menunjukkan ini adalah tipe data primitif khusus
- Keunikan ini menjadikan Symbol sangat berguna untuk menghindari **konflik nama properti** dalam object

---

### 2️⃣ Symbol dengan Deskripsi

```javascript
// Membuat symbol dengan deskripsi
const firstName = Symbol("firstName");
const lastName = Symbol("firstName"); // deskripsi sama

console.log(firstName === lastName); // false - tetap berbeda!
console.log(firstName.description); // "firstName"
console.log(lastName.description); // "firstName"
```

**Output:**
```
false
firstName
firstName
```

**Penjelasan Detail:**
- Parameter string pada `Symbol("firstName")` adalah **deskripsi opsional** yang membantu identifikasi saat debugging
- Deskripsi **BUKAN identifier unik** - dua Symbol dengan deskripsi sama tetap berbeda (`firstName !== lastName`)
- Properti `.description` digunakan untuk **membaca kembali** deskripsi yang diberikan saat pembuatan Symbol
- Deskripsi sangat membantu saat **debugging** karena muncul di console, misalnya: `Symbol(firstName)`
- Meskipun memiliki deskripsi identik, kedua Symbol tetap **unik secara fundamental** dan tidak dapat saling menggantikan

---

### 3️⃣ Menggunakan Symbol sebagai Key Object

```javascript
// Menggunakan symbol sebagai properti key
const id = Symbol("id");
const user = {
    name: "John Doe",
    [id]: 12345 // symbol sebagai key
};

console.log(user.name); // "John Doe"
console.log(user[id]); // 12345
console.log(user.id); // undefined - tidak bisa diakses seperti properti biasa
```

**Output:**
```
John Doe
12345
undefined
```

**Penjelasan Detail:**
- Syntax `[id]` (computed property name) digunakan untuk **menjadikan Symbol sebagai key** dalam object literal
- **Mengapa menggunakan tanda kurung `[]`?**
  - Tanda kurung `[]` memberitahu JavaScript untuk **mengevaluasi ekspresi di dalamnya** sebagai key properti
  - Tanpa `[]`, JavaScript akan membuat properti dengan nama string literal `"id"`, bukan menggunakan nilai dari variabel `id`
  - Dengan `[id]`, JavaScript akan **menggunakan nilai Symbol** yang tersimpan dalam variabel `id` sebagai key
  - Ini disebut **computed property name** (ES6 feature)
  
**Perbandingan:**
```javascript
// TANPA kurung siku - membuat properti string "id"
const obj1 = { id: 12345 };  // key-nya adalah string "id"

// DENGAN kurung siku - menggunakan nilai dari variabel id
const id = Symbol("id");
const obj2 = { [id]: 12345 };  // key-nya adalah Symbol yang tersimpan di variabel id
```

- Properti dengan Symbol key **harus diakses menggunakan bracket notation** `user[id]`, bukan dot notation
- Mencoba akses dengan `user.id` menghasilkan `undefined` karena JavaScript mencari properti string `"id"`, bukan Symbol `id`
- Symbol key sangat berguna untuk **menyimpan metadata** atau informasi internal object tanpa risiko ditimpa oleh properti lain
- Keuntungan utama: **tidak ada konflik nama** - meskipun ada properti string `"id"`, Symbol `id` tetap terpisah dan aman
- Symbol key **tidak enumerable** secara default, sehingga tidak muncul saat melakukan iterasi standar seperti `for...in`

---

### 4️⃣ Symbol Bersifat "Tersembunyi"

```javascript
const secret = Symbol("secret");
const obj = {
    name: "Public Data",
    [secret]: "Hidden Data"
};

// Symbol tidak muncul dalam iterasi normal
console.log(Object.keys(obj)); // ["name"]
console.log(Object.getOwnPropertyNames(obj)); // ["name"]

// Cara mendapatkan symbol keys
console.log(Object.getOwnPropertySymbols(obj)); // [Symbol(secret)]
```

**Output:**
```
["name"]
["name"]
[Symbol(secret)]
```

**Penjelasan Detail:**
- **Mengapa menggunakan tanda kurung `[secret]`?**
  - Tanda kurung `[]` diperlukan untuk **mengevaluasi variabel `secret`** dan menggunakan nilai Symbol-nya sebagai key
  - Tanpa `[]`, kita akan membuat properti string `"secret"` bukan menggunakan Symbol yang tersimpan dalam variabel `secret`
  - Syntax `[secret]` adalah **computed property name** yang memungkinkan penggunaan nilai dinamis sebagai key object
  
**Contoh Perbedaan:**
```javascript
const secret = Symbol("secret");

// SALAH - membuat key string "secret"
const obj1 = { secret: "data" };  // key = string "secret"

// BENAR - menggunakan Symbol sebagai key
const obj2 = { [secret]: "data" };  // key = Symbol dari variabel secret
```

- Properti dengan Symbol key **tidak terdeteksi** oleh metode enumerasi standar seperti `Object.keys()` atau `for...in` loop
- `Object.keys(obj)` hanya mengembalikan **properti string yang enumerable**, yaitu `["name"]` - Symbol `secret` tidak termasuk
- `Object.getOwnPropertyNames(obj)` juga hanya mengembalikan **nama properti berbasis string**, Symbol tetap tersembunyi
- Untuk mengakses Symbol keys, gunakan metode khusus `Object.getOwnPropertySymbols(obj)` yang mengembalikan **array berisi semua Symbol keys**
- Fitur "tersembunyi" ini berguna untuk:
  - **Menyimpan data internal** yang tidak ingin terekspos ke user atau library eksternal
  - **Mencegah iterasi tidak sengaja** - properti Symbol tidak akan muncul saat serialisasi JSON
  - **Metadata object** - informasi tambahan yang tidak seharusnya diakses langsung
- Symbol bukan enkripsi atau security feature - hanya **konvensi pemrograman** untuk properti "semi-private"

---

### 5️⃣ Symbol.for() - Global Symbol Registry

```javascript
// Membuat symbol global
const globalSym1 = Symbol.for("app.id");
const globalSym2 = Symbol.for("app.id");

console.log(globalSym1 === globalSym2); // true - symbol yang sama!

// Mendapatkan key dari global symbol
console.log(Symbol.keyFor(globalSym1)); // "app.id"

// Bandingkan dengan Symbol biasa
const localSym = Symbol("app.id");
console.log(localSym === globalSym1); // false
console.log(Symbol.keyFor(localSym)); // undefined - bukan global symbol
```

**Output:**
```
true
app.id
false
undefined
```

**Penjelasan Detail:**
- `Symbol.for(key)` mencari Symbol dengan **key tertentu** di global symbol registry, jika tidak ada akan **membuatnya**
- Jika Symbol dengan key `"app.id"` sudah ada, `Symbol.for("app.id")` akan mengembalikan **Symbol yang sama** (bukan membuat baru)
- Ini berbeda dengan `Symbol()` yang **selalu membuat Symbol baru**, bahkan dengan deskripsi sama
- `globalSym1 === globalSym2` menghasilkan `true` karena keduanya merujuk **Symbol yang sama** dari registry global
- `Symbol.keyFor(symbol)` mengembalikan **key string** dari global Symbol, atau `undefined` jika Symbol tidak terdaftar secara global
- Symbol biasa (`localSym`) dengan deskripsi `"app.id"` **berbeda** dari global Symbol dengan key `"app.id"`
- **Use case**: 
  - **Sharing Symbol** antar modul/file yang berbeda tanpa import/export
  - **Library/framework** yang perlu Symbol konsisten di berbagai komponen
  - **Plugin system** di mana berbagai plugin perlu mengakses Symbol yang sama
- **Perbedaan kunci**: `Symbol.for()` = reusable & shared, `Symbol()` = unique & isolated

---

## 🎓 Kesimpulan

| Aspek | Penjelasan |
|-------|------------|
| 🔒 **Keunikan** | Setiap Symbol selalu unique, tidak ada duplikasi |
| 🔑 **Key Object** | Ideal untuk membuat properti unik pada object |
| 🙈 **Privacy** | Properti Symbol tidak muncul dalam iterasi normal |
| 🌍 **Global Registry** | `Symbol.for()` untuk membuat shared symbol |

---

> 💡 **Tips:** Gunakan Symbol ketika Anda membutuhkan properti object yang benar-benar unik dan tidak ingin berbenturan dengan properti lain, terutama saat bekerja dengan library atau framework.
