# Prototype Inheritance

- Sekarang kita sudah tahu, bahwa prototype selalu memiliki parent, artinya dia adalah turunan, parent tertinggi adalah Object prototype
- Pertanyaannya bagaimana jika kita ingin melakukan inheritance ke Prototype lain?
- Hal ini juga bisa dilakukan, namun agak sedikit tricky, karena hal ini, sebenarnya untuk JavaScript modern, tidak direkomendasikan lagi praktek OOP menggunakan Prototype, karena di ES6 sudah dikenalkan kata kunci class yang akan nanti dibahas di chapter tersendiri

## Contoh Kode Prototype Inheritance yang Salah ❌

```javascript
function Employee(name) {
    this.name = name;
}

function Manager(name) {
    this.name = name;
}

// ❌ SALAH: Kedua prototype merujuk ke objek yang sama
Manager.prototype = Employee.prototype;

Manager.prototype.sayHello = function (name) {
    console.info(`Hello ${name}, my name is Manager ${this.name}`);
}

Employee.prototype.sayHello = function (name) {
    console.info(`Hello ${name}, my name is Employee ${this.name}`);
}
```

**Penjelasan:**
Kode di atas adalah contoh inheritance yang **salah**. Ketika kita menggunakan `Manager.prototype = Employee.prototype`, kedua prototype akan merujuk ke objek yang sama di memory. Artinya, ketika kita menambahkan method `sayHello` ke `Manager.prototype`, sebenarnya kita juga mengubah `Employee.prototype` karena keduanya adalah referensi ke objek yang sama.

## Penggunaan dan Hasil Output

```javascript
const employee = new Employee("John");
employee.sayHello("Alex")

const manager = new Manager("Sarah");
manager.sayHello("Alex")
```

**Output:**
```
Hello Alex, my name is Employee John
Hello Alex, my name is Employee Sarah
```

**Penjelasan:**
Dari output di atas terlihat masalahnya. Method `sayHello` pada `manager` seharusnya menampilkan "my name is Manager Sarah", tetapi yang muncul adalah "my name is Employee Sarah". Ini terjadi karena method terakhir yang didefinisikan (`Employee.prototype.sayHello`) menimpa method sebelumnya, karena kedua prototype merujuk ke objek yang sama.

## Cara yang Benar untuk Prototype Inheritance ✅

```javascript
function Employee(name) {
    this.name = name;
}

function Manager(name) {
    this.name = name;
}

// ✅ BENAR: Membuat objek baru dengan prototype Employee
Manager.prototype = Object.create(Employee.prototype);

Manager.prototype.sayHello = function (name) {
    console.info(`Hello ${name}, my name is Manager ${this.name}`);
}

Employee.prototype.sayHello = function (name) {
    console.info(`Hello ${name}, my name is Employee ${this.name}`);
}
```

**Penjelasan:**
Cara yang benar adalah menggunakan `Object.create(Employee.prototype)`. Method ini akan membuat objek baru yang prototype-nya merujuk ke `Employee.prototype`. Dengan cara ini, `Manager.prototype` dan `Employee.prototype` adalah objek yang berbeda, sehingga perubahan pada satu prototype tidak akan mempengaruhi prototype yang lain.

## Penggunaan dan Hasil Output yang Benar

```javascript
const employee = new Employee("John");
employee.sayHello("Alex")

const manager = new Manager("Sarah");
manager.sayHello("Alex")
```

**Output:**
```
Hello Alex, my name is Employee John
Hello Alex, my name is Manager Sarah
```

**Penjelasan:**
Sekarang hasilnya sudah benar! Method `sayHello` pada `employee` menampilkan "my name is Employee John", dan method `sayHello` pada `manager` menampilkan "my name is Manager Sarah". Ini karena setiap prototype memiliki method `sayHello` yang berbeda dan tidak saling menimpa.
