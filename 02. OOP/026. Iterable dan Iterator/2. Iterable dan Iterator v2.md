# Iterable dan Iterator di JavaScript

## üìñ Pengenalan

**Iterable** adalah salah satu fitur penting yang diperkenalkan di ES6 (ECMAScript 2015). Iterable merupakan spesial object yang mengikuti standarisasi tertentu, sehingga memungkinkan kita untuk melakukan iterasi (perulangan) terhadap data menggunakan loop `for...of`.

### Contoh Built-in Iterable
Beberapa tipe data JavaScript yang sudah mengimplementasikan standar Iterable:
- **String** - dapat diiterasi karakter per karakter
- **Array** - dapat diiterasi elemen per elemen
- **Map** - dapat diiterasi pasangan key-value
- **Set** - dapat diiterasi nilai unik per nilai
- **NodeList** - dapat diiterasi node DOM

---

## üîç Konsep Dasar

### Apa itu Iterable?

Iterable adalah object yang mengimplementasikan method `[Symbol.iterator]()`. Method ini mengembalikan sebuah **Iterator** yang digunakan untuk melakukan iterasi.

**Interface Iterable (TypeScript):**
```typescript
interface Iterable<T> {
    [Symbol.iterator](): Iterator<T>;
}
```

**Penjelasan:**
- `[Symbol.iterator]` adalah method wajib yang harus diimplementasikan
- Method ini harus mengembalikan object Iterator
- `T` adalah tipe generic untuk tipe data yang akan diiterasi

### Apa itu Iterator?

Iterator adalah object yang memiliki method `next()` untuk mengambil nilai berikutnya dalam urutan iterasi.

**Interface Iterator (TypeScript):**
```typescript
interface Iterator<T, TReturn = any, TNext = undefined> {
    next(...args: [] | [TNext]): IteratorResult<T, TReturn>;
    return?(value?: TReturn): IteratorResult<T, TReturn>;
    throw?(e?: any): IteratorResult<T, TReturn>;
}
```

**Penjelasan:**
- `next()` - **Method wajib** untuk mendapatkan nilai berikutnya
- `return()` - Method opsional untuk menghentikan iterasi lebih awal
- `throw()` - Method opsional untuk melempar error dalam iterasi

### IteratorResult

Setiap pemanggilan `next()` mengembalikan object dengan struktur `IteratorResult`.

**Interface IteratorResult (TypeScript):**
```typescript
interface IteratorYieldResult<TYield> {
    done?: false;
    value: TYield;
}

interface IteratorReturnResult<TReturn> {
    done: true;
    value: TReturn;
}

type IteratorResult<T, TReturn = any> = 
    IteratorYieldResult<T> | IteratorReturnResult<TReturn>;
```

**Penjelasan:**
- `value` - Nilai yang dikembalikan pada iterasi saat ini
- `done` - Status iterasi:
  - `false` = iterasi masih berlanjut
  - `true` = iterasi sudah selesai

---

## ‚öôÔ∏è Cara Kerja Iterable dan Iterator

1. Ketika `for...of` dipanggil pada object Iterable, JavaScript akan memanggil method `[Symbol.iterator]()`
2. Method tersebut mengembalikan object Iterator baru
3. Loop akan memanggil method `next()` pada Iterator secara berulang
4. Setiap pemanggilan `next()` mengembalikan `{ value, done }`
5. Loop berhenti ketika `done` bernilai `true`

**Keuntungan:**
- Setiap iterasi mendapat Iterator baru, sehingga aman untuk iterasi berulang
- Tidak ada konflik state antara iterasi yang berbeda

---

## üíª Implementasi Custom Iterable

Mari kita buat implementasi Iterable dan Iterator dari awal dengan contoh **Counter** yang menghitung dari nilai awal hingga nilai maksimum.

### Langkah 1: Membuat CounterIteratorResult

```javascript
class CounterIteratorResult {
    constructor(value, done) {
        this.value = value;
        this.done = done;
    }
}
```

**Fungsi:** Class helper untuk membuat object hasil iterasi dengan format standar `{ value, done }`.

### Langkah 2: Membuat CounterIterator

```javascript
class CounterIterator {
    constructor(value, max) {
        this.value = value;
        this.max = max;
    }

    next() {
        try {
            if (this.value > this.max) {
                return new CounterIteratorResult(this.value, true);
            } else {
                return new CounterIteratorResult(this.value, false);
            }
        } finally {
            this.value++;
        }
    }
}
```

**Penjelasan:**
- Menyimpan state iterasi: nilai saat ini (`value`) dan batas maksimum (`max`)
- Method `next()` mengecek apakah iterasi sudah selesai (`value > max`)
- Block `finally` memastikan `value` selalu increment setelah setiap pemanggilan
- Mengembalikan object dengan property `value` dan `done`

### Langkah 3: Membuat Counter Iterable

```javascript
class Counter {
    constructor(value, max) {
        this.value = value;
        this.max = max;
    }

    [Symbol.iterator]() {
        return new CounterIterator(this.value, this.max);
    }
}
```

**Penjelasan:**
- Mengimplementasikan method `[Symbol.iterator]()` sesuai kontrak Iterable
- Method ini mengembalikan instance **baru** dari `CounterIterator` setiap kali dipanggil
- Dengan ini, object `Counter` dapat digunakan dengan `for...of` loop

### Langkah 4: Menggunakan Counter

```javascript
const counter = new Counter(1, 10);

for (const element of counter) {
    console.info(element);
}
```

**Output:**
```
1
2
3
4
5
6
7
8
9
10
```

**Penjelasan:**
- Membuat instance Counter dengan nilai awal 1 dan maksimum 10
- Loop `for...of` secara otomatis memanggil `[Symbol.iterator]()`
- Setiap iterasi memanggil `next()` dan mengambil `value` sampai `done === true`

---

## üîÑ Iterasi Berulang

Salah satu keunggulan implementasi Iterable adalah kemampuan melakukan iterasi berulang tanpa konflik:

```javascript
const counter = new Counter(1, 5);

// Iterasi pertama
for (const num of counter) {
    console.log('First loop:', num);
}

// Iterasi kedua - tetap berfungsi!
for (const num of counter) {
    console.log('Second loop:', num);
}
```

Setiap loop mendapat Iterator baru, sehingga state tidak saling mengganggu.

---

## üìö Kesimpulan

**Iterable dan Iterator** adalah konsep fundamental dalam JavaScript modern yang memungkinkan:
- Standardisasi cara melakukan iterasi pada custom object
- Kompatibilitas dengan `for...of` loop
- Iterasi yang aman dan dapat diulang
- State management yang terisolasi untuk setiap iterasi

Dengan memahami konsep ini, kita dapat membuat struktur data custom yang powerful dan mudah digunakan.
