# Iterable dan Iterator

- Salah satu fitur terbaru di ES6 adalah iterable
- Iterable adalah spesial object yang memiliki standarisasi
- Dengan mengikuti standarisasi Iterable, secara otomatis kita bisa melakukan iterasi terdapat data tersebut dengan menggunakan perulangan for...of
- Contoh yang sudah mengikuti standarisasi Iterable adalah string, Array, Object, dan lain-lain

## Kode: Kontrak Iterable (dalam TypeScript)

```typescript
interface Iterable<T> {
    [Symbol.iterator](): Iterator<T>;
}
```

**Penjelasan:**
- Interface `Iterable<T>` mendefinisikan kontrak untuk objek yang dapat diiterasi
- `[Symbol.iterator]` adalah method khusus yang harus diimplementasikan
- Method ini mengembalikan objek `Iterator<T>` yang digunakan untuk melakukan iterasi
- `T` adalah tipe generic yang merepresentasikan tipe data yang akan diiterasi

## Kode: Kontrak Iterator (dalam TypeScript)

```typescript
interface Iterator<T, TReturn = any, TNext = undefined> {
    // NOTE: 'next' is defined using a tuple to ensure we report the correct assignability errors in all places.
    next(...args: [] | [TNext]): IteratorResult<T, TReturn>;
    return?(value?: TReturn): IteratorResult<T, TReturn>;
    throw?(e?: any): IteratorResult<T, TReturn>;
}
```

**Penjelasan:**
- Interface `Iterator<T, TReturn, TNext>` mendefinisikan kontrak untuk objek iterator
- `next()` adalah method yang harus ada, digunakan untuk mendapatkan nilai berikutnya dalam iterasi
- `return()` adalah method opsional untuk menghentikan iterasi dan mengembalikan nilai
- `throw()` adalah method opsional untuk melempar error dalam iterasi
- Semua method mengembalikan `IteratorResult<T, TReturn>` yang berisi nilai dan status iterasi

## Kontrak: IteratorResult (dalam TypeScript)

```typescript
interface IteratorYieldResult<TYield> {
    done?: false;
    value: TYield;
}

interface IteratorReturnResult<TReturn> {
    done: true;
    value: TReturn;
}

type IteratorResult<T, TReturn = any> = IteratorYieldResult<T> | IteratorReturnResult<TReturn>;
```

**Penjelasan:**
- `IteratorYieldResult<TYield>` merepresentasikan hasil iterasi yang masih berlanjut (done: false)
- `IteratorReturnResult<TReturn>` merepresentasikan hasil iterasi yang sudah selesai (done: true)
- `IteratorResult<T, TReturn>` adalah union type dari kedua interface di atas
- Setiap hasil iterasi memiliki property `done` (status) dan `value` (nilai)

## Cara Kerja Iterable dan Iterator

- Jika kita mengikuti kontrak Iterable, maka object yang kita buat akan bisa dilakukan iterasi menggunakan for...of
- Setiap kita melakukan perulangan, object Iterator akan dibuat
- Hal ini menjadi aman jika kita melakukan iterasi berulang-ulang, karena Iterator baru akan dibuat terus menerus

## Kode: Membuat Counter Iterator Result

```javascript
class CounterIteratorResult {
    constructor(value, done) {
        this.done = done;
        this.value = value;
    }
}
```

**Penjelasan:**
- Class `CounterIteratorResult` digunakan untuk membuat object hasil iterasi
- Constructor menerima dua parameter: `value` (nilai saat ini) dan `done` (status iterasi)
- Property `done` menunjukkan apakah iterasi sudah selesai (true) atau masih berlanjut (false)
- Property `value` menyimpan nilai yang dikembalikan pada iterasi saat ini

## Kode: Membuat Counter Iterator

```javascript
class CounterIterator {
    constructor(value, max) {
        this.value = value;
        this.max = max;
    }

    next() {
        try {
            if (this.value > this.max) {
                return new CounterIteratorResult(this.value, true);
            } else {
                return new CounterIteratorResult(this.value, false);
            }
        } finally {
            this.value++;
        }
    }
}
```

**Penjelasan:**
- Class `CounterIterator` mengimplementasikan iterator untuk menghitung dari nilai awal hingga nilai maksimum
- Constructor menerima `value` (nilai awal) dan `max` (nilai maksimum)
- Method `next()` mengembalikan nilai berikutnya dalam iterasi
- Jika `value > max`, iterasi selesai (done: true), jika tidak iterasi masih berlanjut (done: false)
- Block `finally` memastikan `value` selalu bertambah setelah setiap pemanggilan `next()`

## Kode: Membuat Counter Iterable

```javascript
class Counter {
    constructor(value, max) {
        this.value = value;
        this.max = max;
    }

    [Symbol.iterator]() {
        return new CounterIterator(this.value, this.max);
    }
}
```

**Penjelasan:**
- Class `Counter` mengimplementasikan interface Iterable
- Constructor menerima `value` (nilai awal) dan `max` (nilai maksimum)
- Method `[Symbol.iterator]()` adalah implementasi dari kontrak Iterable
- Method ini mengembalikan instance baru dari `CounterIterator` setiap kali dipanggil
- Dengan implementasi ini, object `Counter` dapat diiterasi menggunakan for...of loop

## Kode: Menggunakan Counter Iterable

```javascript
const counter = new Counter(1, 10)
for (const element of counter) {
    console.info(element);
}
```

**Penjelasan:**
- Membuat instance `Counter` dengan nilai awal 1 dan nilai maksimum 10
- Menggunakan for...of loop untuk melakukan iterasi terhadap object `counter`
- Setiap nilai dalam iterasi akan dicetak menggunakan `console.info()`

**Output:**
```
1
2
3
4
5
6
7
8
9
10
```
